// This file was generated by colf(1); DO NOT EDIT
// The compiler used schema file test.colf.

#ifndef COLFER_H
#define COLFER_H

#include <limits.h>
#include <stdint.h>
#include <string.h>
#include <time.h>


#if CHAR_BIT != 8
#error "octet byte size"
#endif

#ifdef __cplusplus
extern "C" {
#endif


// colfer_size_max is the upper limit for serial octet sizes.
extern size_t colfer_size_max;

// colfer_list_max is the upper limit for the number of elements in a list.
extern size_t colfer_list_max;


typedef struct {
	float* list;
	size_t len;
} colfer_float32_list;

typedef struct {
	double* list;
	size_t len;
} colfer_float64_list;

typedef struct {
	// sec is the Unix time.
	time_t sec;
	// nanos is the nanosecond adjustment.
	time_t nanos;
} colfer_timestamp;

// colfer_text is a UTF-8 CLOB.
typedef struct {
	char* utf8;
	size_t len;
} colfer_text;

typedef struct {
	colfer_text* list;
	size_t len;
} colfer_text_list;

// colfer_binary is a BLOB.
typedef struct {
	uint8_t* octets;
	size_t len;
} colfer_binary;

typedef struct {
	colfer_binary* list;
	size_t len;
} colfer_binary_list;



// Package gen tests all field mapping options.

// O contains all supported data types.
typedef struct gen_o gen_o;

typedef struct {
	struct gen_o* list;
	size_t len;
} gen_o_list;

struct gen_o {
	// b tests booleans.
	char b;

	// u8 tests unsigned 8-bit integers.
	uint8_t u8;

	// u16 tests unsigned 16-bit integers.
	uint16_t u16;

	// u32 tests unsigned 32-bit integers.
	uint32_t u32;

	// u64 tests unsigned 64-bit integers.
	uint64_t u64;

	// i32 tests signed 32-bit integers.
	int32_t i32;

	// i64 tests signed 64-bit integers.
	int64_t i64;

	// f32 tests 32-bit floating points.
	float f32;

	// f32s tests 32-bit floating point lists.
	colfer_float32_list f32s;

	// f64 tests 64-bit floating points.
	double f64;

	// f64s tests 64-bit floating point lists.
	colfer_float64_list f64s;

	// t tests timestamps.
	colfer_timestamp t;

	// a tests binaries.
	colfer_binary a;

	// as tests binary lists.
	colfer_binary_list as;

	// s tests text.
	colfer_text s;

	// ss tests text lists.
	colfer_text_list ss;

	// o tests nested data structures.
	gen_o* o;

	// os tests data structure lists.
	gen_o_list os;
};


// marshal_len returns the Colfer serial byte size.
size_t gen_o_marshal_len(const gen_o* o);

// marshal encodes O as Colfer into buf and returns the number of octets written.
// The marshaller writes never more than colfer_size_max octets.
size_t gen_o_marshal(const gen_o* o, void* buf);

// unmarshal decodes data as Colfer and returns the number of octets read.
// The data is read up to datalen or colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values.
// EWOULDBLOCK means incomplete data. It is safe to reuse o for this case without initiation.
// ERANGE implies a breach of either colfer_size_max or colfer_list_max.
// EILSEQ means a schema mismatch.
size_t gen_o_unmarshal(gen_o* o, const void* data, size_t datalen);


#ifdef __cplusplus
} // extern "C"
#endif

#endif
