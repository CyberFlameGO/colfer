package testdata.bench;

// This file was generated by colf(1); DO NOT EDIT

import java.nio.ByteBuffer;
import java.util.InputMismatchException;

import static java.lang.String.format;


/**
 * @author Commander Colfer
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
public class Colfer implements java.io.Serializable {

	/** The upper limit for serial byte sizes. */
	public static int colferSizeMax = 16 * 1024 * 1024;

	/** The upper limit for text and binary byte sizes. */
	public static int colferFieldMax = 1024 * 1024;

	/** The upper limit for the number of elements in a list. */
	public static int colferListMax = 64 * 1024;

	private static final java.nio.charset.Charset _utf8 = java.nio.charset.Charset.forName("UTF-8");
	private static final byte[] _zeroAddr = new byte[0];

	public long key;
	public String host = "";
	public byte[] addr = _zeroAddr;
	public int port;
	public long size;
	public long hash;
	public double ratio;
	public boolean route;


	/**
	 * Serializes the object.
	 * The {@link ByteBuffer#limit()} is set when {@link ByteBuffer#remaining()} exceeds {@link #colferSizeMax}.
	 * @param buf the data destination.
	 */
	public final void marshal(ByteBuffer buf)
	throws java.nio.BufferOverflowException, InputMismatchException {
		buf.order(java.nio.ByteOrder.BIG_ENDIAN);
		if (buf.remaining() > colferSizeMax)
			buf.limit(buf.position() + colferSizeMax);

		if (this.key != 0) {
			long x = this.key;
			if (x < 0) {
				x = -x;
				buf.put((byte) (0 | 0x80));
			} else
				buf.put((byte) 0);
			putVarint(buf, x);
		}

		if (! this.host.isEmpty()) {
			ByteBuffer bytes = this._utf8.encode(this.host);
			buf.put((byte) 1);
			int length = bytes.limit();
			if (length > colferFieldMax)
				throw new InputMismatchException(format("colfer: field testdata/bench.Colfer.host exceeds %d bytes", colferFieldMax));
			putVarint(buf, length);
			buf.put(bytes);
		}

		if (this.addr.length != 0) {
			buf.put((byte) 2);
			int length = this.addr.length;
			if (length > colferFieldMax)
				throw new InputMismatchException(format("colfer: field testdata/bench.Colfer.addr exceeds %d bytes", colferFieldMax));
			putVarint(buf, length);
			buf.put(this.addr);
		}

		if (this.port != 0) {
			int x = this.port;
			if (x < 0) {
				x = -x;
				buf.put((byte) (3 | 0x80));
			} else
				buf.put((byte) 3);
			putVarint(buf, x);
		}

		if (this.size != 0) {
			long x = this.size;
			if (x < 0) {
				x = -x;
				buf.put((byte) (4 | 0x80));
			} else
				buf.put((byte) 4);
			putVarint(buf, x);
		}

		if (this.hash != 0) {
			buf.put((byte) 5);
			putVarint(buf, this.hash);
		}

		if (this.ratio != 0.0) {
			buf.put((byte) 6);
			buf.putDouble(this.ratio);
		}

		if (this.route) {
			buf.put((byte) 7);
		}

		buf.put((byte) 0x7f);
	}

	/**
	 * Deserializes the object.
	 * The {@link ByteBuffer#limit()} is set when {@link ByteBuffer#remaining()} exceeds {@link #colferSizeMax}.
	 * @param buf the data source.
	 */
	public final void unmarshal(ByteBuffer buf)
	throws java.nio.BufferUnderflowException, InputMismatchException {
		if (buf.remaining() > colferSizeMax)
			buf.limit(buf.position() + colferSizeMax);
		byte header = buf.get();

		if (header == (byte) 0) {
			this.key = getVarint64(buf);
			header = buf.get();
		} else if (header == (byte) (0 | 0x80)) {
			this.key = (~getVarint64(buf)) + 1;
			header = buf.get();
		}

		if (header == (byte) 1) {
			int length = getVarint32(buf);
			if (length > colferFieldMax)
				throw new InputMismatchException(format("colfer: field testdata/bench.Colfer.host exceeds %d bytes", colferFieldMax));
			ByteBuffer blob = ByteBuffer.allocate(length);
			buf.get(blob.array());
			this.host = this._utf8.decode(blob).toString();
			header = buf.get();
		}

		if (header == (byte) 2) {
			int length = getVarint32(buf);
			if (length > colferFieldMax)
				throw new InputMismatchException(format("colfer: field testdata/bench.Colfer.addr exceeds %d bytes", colferFieldMax));
			this.addr = new byte[length];
			buf.get(this.addr);
			header = buf.get();
		}

		if (header == (byte) 3) {
			this.port = getVarint32(buf);
			header = buf.get();
		} else if (header == (byte) (3 | 0x80)) {
			this.port = (~getVarint32(buf)) + 1;
			header = buf.get();
		}

		if (header == (byte) 4) {
			this.size = getVarint64(buf);
			header = buf.get();
		} else if (header == (byte) (4 | 0x80)) {
			this.size = (~getVarint64(buf)) + 1;
			header = buf.get();
		}

		if (header == (byte) 5) {
			this.hash = getVarint64(buf);
			header = buf.get();
		}

		if (header == (byte) 6) {
			this.ratio = buf.getDouble();
			header = buf.get();
		}

		if (header == (byte) 7) {
			this.route = true;
			header = buf.get();
		}

		if (header != 0x7f)
			throw new InputMismatchException(format("colfer: unknown header at byte %d", buf.position() - 1));
	}

	public long getKey() {
		return this.key;
	}

	public void setKey(long value) {
		this.key = value;
	}

	public String getHost() {
		return this.host;
	}

	public void setHost(String value) {
		this.host = value;
	}

	public byte[] getAddr() {
		return this.addr;
	}

	public void setAddr(byte[] value) {
		this.addr = value;
	}

	public int getPort() {
		return this.port;
	}

	public void setPort(int value) {
		this.port = value;
	}

	public long getSize() {
		return this.size;
	}

	public void setSize(long value) {
		this.size = value;
	}

	public long getHash() {
		return this.hash;
	}

	public void setHash(long value) {
		this.hash = value;
	}

	public double getRatio() {
		return this.ratio;
	}

	public void setRatio(double value) {
		this.ratio = value;
	}

	public boolean getRoute() {
		return this.route;
	}

	public void setRoute(boolean value) {
		this.route = value;
	}

	@Override
	public final int hashCode() {
		return java.util.Objects.hash(0x7f, key, host, addr, port, size, hash, ratio, route);
	}

	@Override
	public final boolean equals(Object o) {
		return o instanceof Colfer && equals((Colfer) o);
	}

	public final boolean equals(Colfer o) {
		return o != null
			&& this.key == o.key
			&& java.util.Objects.equals(this.host, o.host)
			&& java.util.Arrays.equals(this.addr, o.addr)
			&& this.port == o.port
			&& this.size == o.size
			&& this.hash == o.hash
			&& java.util.Objects.equals(this.ratio, o.ratio)
			&& this.route == o.route;
	}

	/**
	 * Serializes an integer.
	 * @param buf the data destination.
	 * @param x the value.
	 */
	private static void putVarint(ByteBuffer buf, int x) {
		while ((x & 0xffffff80) != 0) {
			buf.put((byte) (x | 0x80));
			x >>>= 7;
		}
		buf.put((byte) x);
	}

	/**
	 * Serializes an integer.
	 * @param buf the data destination.
	 * @param x the value.
	 */
	private static void putVarint(ByteBuffer buf, long x) {
		while ((x & 0xffffffffffffff80L) != 0) {
			buf.put((byte) (x | 0x80));
			x >>>= 7;
		}
		buf.put((byte) x);
	}

	/**
	 * Deserializes a 32-bit integer.
	 * @param buf the data source.
	 * @return the value.
	 */
	private static int getVarint32(ByteBuffer buf) {
		int x = 0;
		for (int shift = 0; shift != 28; shift += 7) {
			int b = buf.get() & 0xff;
			x |= (b & 0x7f) << shift;
			if (b < 0x80) return x;
		}
		long b = buf.get() & 0xffL;
		x |= b << 28;
		return x;
	}

	/**
	 * Deserializes a 64-bit integer.
	 * @param buf the data source.
	 * @return the value.
	 */
	private static long getVarint64(ByteBuffer buf) {
		long x = 0;
		for (int shift = 0; shift != 63; shift += 7) {
			long b = buf.get() & 0xffL;
			x |= (b & 0x7f) << shift;
			if (b < 0x80) return x;
		}
		buf.get();
		x |= 1L << 63;
		return x;
	}

}
