// This file was generated by colf(1); DO NOT EDIT

var bench = new function() {
	const EOF = 'colfer: EOF';

	this.marshalColfer = function(o) {
		var segs = [[128]];

		if (o.key) {
			var seg = [4];
			if (o.key < 0) {
				seg[0] |= 128;
				if (o.key < -Number.MAX_SAFE_INTEGER) throw 'colfer: field key exceeds Number.MAX_SAFE_INTEGER';
				encodeVarint(seg, -o.key);
			} else {
				if (o.key > Number.MAX_SAFE_INTEGER) throw 'colfer: field key exceeds Number.MAX_SAFE_INTEGER';
				encodeVarint(seg, o.key);
			}
			segs.push(seg);
		}

		if (o.host) {
			var utf = encodeUTF8(o.host);
			var seg = [1];
			encodeVarint(seg, utf.length);
			segs.push(seg);
			segs.push(utf)
		}

		if (o.addr) {
			var seg = [2];
			encodeVarint(seg, o.addr.length);
			segs.push(seg);
			segs.push(o.addr);
		}

		if (o.port) {
			var seg = [3];
			if (o.port < 0) {
				seg[0] |= 128;
				if (o.port < -2147483648) throw 'colfer: field port exceeds 32-bit range';
				encodeVarint(seg, -o.port);
			} else {
				if (o.port > 2147483647) throw 'colfer: field port exceeds 32-bit range';
				encodeVarint(seg, o.port);
			}
			segs.push(seg);
		}

		if (o.size) {
			var seg = [4];
			if (o.size < 0) {
				seg[0] |= 128;
				if (o.size < -Number.MAX_SAFE_INTEGER) throw 'colfer: field size exceeds Number.MAX_SAFE_INTEGER';
				encodeVarint(seg, -o.size);
			} else {
				if (o.size > Number.MAX_SAFE_INTEGER) throw 'colfer: field size exceeds Number.MAX_SAFE_INTEGER';
				encodeVarint(seg, o.size);
			}
			segs.push(seg);
		}

		if (o.hash) {
			var seg = [5];
			if (o.hash > Number.MAX_SAFE_INTEGER) throw 'colfer: field hash exceeds Number.MAX_SAFE_INTEGER';
			encodeVarint(seg, o.hash);
			segs.push(seg);
		}

		if (o.ratio || Number.isNaN(o.ratio)) {
			var bytes = new Uint8Array(9);
			bytes[0] = 6;
			new DataView(bytes.buffer).setFloat64(1, o.ratio);
			segs.push(bytes);
		}

		if (o.route) {
			segs.push([7]);
		}

		var size = 1;
		segs.forEach(function(seg) {
			size += seg.length;
		});

		var bytes = new Uint8Array(size);
		var i = 0;
		segs.forEach(function(seg) {
			bytes.set(seg, i);
			i += seg.length;
		});
		bytes[i] = 127;
		return bytes;
	}

	this.unmarshalColfer = function(data) {
		if (!data || ! data.length) return null;
		if (data[0] != 0x80) throw "colfer: unknown header at byte 0";
		var i = 1;
		var header;
		var readHeader = function() {
			if (i == data.length) throw EOF;
			header = data[i++];
		}

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw EOF;
			}
			return -1;
		}

		var o = {};
		readHeader();

		if (header == 0) {
			var x = readVarint();
			if (x < 0) throw 'colfer: field key exceeds Number.MAX_SAFE_INTEGER';
			o.key = x;
			readHeader();
		} else if (header == (0 | 128)) {
			var x = readVarint();
			if (x < 0) throw 'colfer: field key exceeds Number.MAX_SAFE_INTEGER';
			o.key = -1 * x;
			readHeader();
		}

		if (header == 1) {
			var length = readVarint();
			if (length < 0) throw 'colfer: field host length exceeds Number.MAX_SAFE_INTEGER';
			var to = i + length;
			if (to > data.length) throw EOF;
			o.host = decodeUTF8(data.subarray(i, to));
			i = to;
			readHeader();
		}

		if (header == 2) {
			var length = readVarint();
			if (length < 0) throw 'colfer: field addr length exceeds Number.MAX_SAFE_INTEGER';
			var to = i + length;
			if (to > data.length) throw EOF;
			o.addr = data.subarray(i, to);
			i = to;
			readHeader();
		}

		if (header == 3) {
			var x = readVarint();
			if (x < 0) throw 'colfer: field port exceeds Number.MAX_SAFE_INTEGER';
			o.port = x;
			readHeader();
		} else if (header == (3 | 128)) {
			var x = readVarint();
			if (x < 0) throw 'colfer: field port exceeds Number.MAX_SAFE_INTEGER';
			o.port = -1 * x;
			readHeader();
		}

		if (header == 4) {
			var x = readVarint();
			if (x < 0) throw 'colfer: field size exceeds Number.MAX_SAFE_INTEGER';
			o.size = x;
			readHeader();
		} else if (header == (4 | 128)) {
			var x = readVarint();
			if (x < 0) throw 'colfer: field size exceeds Number.MAX_SAFE_INTEGER';
			o.size = -1 * x;
			readHeader();
		}

		if (header == 5) {
			var x = readVarint();
			if (x < 0) throw 'colfer: field hash exceeds Number.MAX_SAFE_INTEGER';
			o.hash = x;
			readHeader();
		}

		if (header == 6) {
			if (i + 8 > data.length) throw EOF;
			o.ratio = new DataView(data.buffer).getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 7) {
			o.route = true;
			readHeader();
		}

		if (header != 127) throw 'colfer: unknown header at byte ' + (i - 1);
		if (i != data.length) throw 'colfer: data continuation at byte ' + i
		return o;
	}

	var encodeVarint = function(bytes, x) {
		while (x > 127) {
			bytes.push(x|128);
			x /= 128;
		}
		bytes.push(x&127);
		return bytes;
	}

	// Marshals a string to Uint8Array.
	var encodeUTF8 = function(s) {
		var i = 0;
		var bytes = new Uint8Array(s.length * 4);
		for (var ci = 0; ci != s.length; ci++) {
			var c = s.charCodeAt(ci);
			if (c < 128) {
				bytes[i++] = c;
				continue;
			}
			if (c < 2048) {
				bytes[i++] = c >> 6 | 192;
			} else {
				if (c > 0xd7ff && c < 0xdc00) {
					if (++ci == s.length) throw 'UTF-8 encode: incomplete surrogate pair';
					var c2 = s.charCodeAt(ci);
					if (c2 < 0xdc00 || c2 > 0xdfff) throw 'UTF-8 encode: second char code 0x' + c2.toString(16) + ' at index ' + ci + ' in surrogate pair out of range';
					c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
					bytes[i++] = c >> 18 | 240;
					bytes[i++] = c>> 12 & 63 | 128;
				} else { // c <= 0xffff
					bytes[i++] = c >> 12 | 224;
				}
				bytes[i++] = c >> 6 & 63 | 128;
			}
			bytes[i++] = c & 63 | 128;
		}
		return bytes.subarray(0, i);
	}

	// Unmarshals an Uint8Array to string.
	var decodeUTF8 = function(bytes) {
		var s = '';
		var i = 0;
		while (i < bytes.length) {
			var c = bytes[i++];
			if (c > 127) {
				if (c > 191 && c < 224) {
					if (i >= bytes.length) throw 'UTF-8 decode: incomplete 2-byte sequence';
					c = (c & 31) << 6 | bytes[i] & 63;
				} else if (c > 223 && c < 240) {
					if (i + 1 >= bytes.length) throw 'UTF-8 decode: incomplete 3-byte sequence';
					c = (c & 15) << 12 | (bytes[i] & 63) << 6 | bytes[++i] & 63;
				} else if (c > 239 && c < 248) {
					if (i+2 >= bytes.length) throw 'UTF-8 decode: incomplete 4-byte sequence';
					c = (c & 7) << 18 | (bytes[i] & 63) << 12 | (bytes[++i] & 63) << 6 | bytes[++i] & 63;
				} else throw 'UTF-8 decode: unknown multibyte start 0x' + c.toString(16) + ' at index ' + (i - 1);
				++i;
			}

			if (c <= 0xffff) s += String.fromCharCode(c);
			else if (c <= 0x10ffff) {
				c -= 0x10000;
				s += String.fromCharCode(c >> 10 | 0xd800)
				s += String.fromCharCode(c & 0x3FF | 0xdc00)
			} else throw 'UTF-8 decode: code point 0x' + c.toString(16) + ' exceeds UTF-16 reach';
		}
		return s;
	}
}
