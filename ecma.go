package colfer

import (
	"os"
	"path/filepath"
	"text/template"
)

// GenerateECMA writes the code into file "Colfer.js".
func GenerateECMA(basedir string, structs []*Struct) error {
	if err := os.MkdirAll(basedir, os.ModeDir|os.ModePerm); err != nil {
		return err
	}
	f, err := os.Create(filepath.Join(basedir, "Colfer.js"))
	if err != nil {
		return err
	}
	defer f.Close()

	perPkg := make(map[string][]*Struct)
	for _, s := range structs {
		perPkg[s.Pkg.Name] = append(perPkg[s.Pkg.Name], s)
	}

	t := template.New("ecma-code").Delims("<:", ":>")
	template.Must(t.Parse(ecmaCode))
	template.Must(t.New("marshal").Parse(ecmaMarshal))
	template.Must(t.New("unmarshal").Parse(ecmaUnmarshal))

	return t.Execute(f, perPkg)
}

const ecmaCode = `// This file was generated by colf(1); DO NOT EDIT
<:range $pkg, $structs := .:>
var <:$pkg:> = new function() {
	const EOF = 'colfer: EOF';
	const StructMis = 'colfer: struct header mismatch';
	const UnknownField = 'colfer: unknown field header';
<:range $structs:>
<:template "marshal" .:>
<:template "unmarshal" .:>
<:end:>
	var joinSegs = function(segs) {
		var size = 0;
		segs.forEach(function(seg) {
			size += seg.length;
		});

		var bytes = new Uint8Array(size);
		var i = 0;
		segs.forEach(function(seg) {
			bytes.set(seg, i);
			i += seg.length;
		});
		return bytes;
	}

	var encodeVarint = function(bytes, x) {
		while (x > 127) {
			bytes.push(x|128);
			x /= 128;
		}
		bytes.push(x&127);
		return bytes;
	}

	// Marshals a string to Uint8Array.
	var encodeUTF8 = function(s) {
		var i = 0;
		var bytes = new Uint8Array(s.length * 4);
		for (var ci = 0; ci != s.length; ci++) {
			var c = s.charCodeAt(ci);
			if (c < 128) {
				bytes[i++] = c;
				continue;
			}
			if (c < 2048) {
				bytes[i++] = c >> 6 | 192;
			} else {
				if (c > 0xd7ff && c < 0xdc00) {
					if (++ci == s.length) throw 'UTF-8 encode: incomplete surrogate pair';
					var c2 = s.charCodeAt(ci);
					if (c2 < 0xdc00 || c2 > 0xdfff) throw 'UTF-8 encode: second char code 0x' + c2.toString(16) + ' at index ' + ci + ' in surrogate pair out of range';
					c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
					bytes[i++] = c >> 18 | 240;
					bytes[i++] = c>> 12 & 63 | 128;
				} else { // c <= 0xffff
					bytes[i++] = c >> 12 | 224;
				}
				bytes[i++] = c >> 6 & 63 | 128;
			}
			bytes[i++] = c & 63 | 128;
		}
		return bytes.subarray(0, i);
	}

	// Unmarshals an Uint8Array to string.
	var decodeUTF8 = function(bytes) {
		var s = '';
		var i = 0;
		while (i < bytes.length) {
			var c = bytes[i++];
			if (c > 127) {
				if (c > 191 && c < 224) {
					if (i >= bytes.length) throw 'UTF-8 decode: incomplete 2-byte sequence';
					c = (c & 31) << 6 | bytes[i] & 63;
				} else if (c > 223 && c < 240) {
					if (i + 1 >= bytes.length) throw 'UTF-8 decode: incomplete 3-byte sequence';
					c = (c & 15) << 12 | (bytes[i] & 63) << 6 | bytes[++i] & 63;
				} else if (c > 239 && c < 248) {
					if (i+2 >= bytes.length) throw 'UTF-8 decode: incomplete 4-byte sequence';
					c = (c & 7) << 18 | (bytes[i] & 63) << 12 | (bytes[++i] & 63) << 6 | bytes[++i] & 63;
				} else throw 'UTF-8 decode: unknown multibyte start 0x' + c.toString(16) + ' at index ' + (i - 1);
				++i;
			}

			if (c <= 0xffff) s += String.fromCharCode(c);
			else if (c <= 0x10ffff) {
				c -= 0x10000;
				s += String.fromCharCode(c >> 10 | 0xd800)
				s += String.fromCharCode(c & 0x3FF | 0xdc00)
			} else throw 'UTF-8 decode: code point 0x' + c.toString(16) + ' exceeds UTF-16 reach';
		}
		return s;
	}
}
<:end:>`

const ecmaMarshal = `	this.marshal<:.NameTitle:> = function(o) {
		var segs = [[128]];
<:range .Fields:><:if eq .Type "bool":>
		if (o.<:.Name:>) {
			segs.push([<:.Index:>]);
		}
<:else if eq .Type "uint32":>
		if (o.<:.Name:>) {
			if (o.<:.Name:> > 4294967295)
				throw 'colfer: field "<:.Name:>" overflow: ' + o.<:.Name:>;
			var seg = [<:.Index:>];
			encodeVarint(seg, o.<:.Name:>);
			segs.push(seg);
		}
<:else if eq .Type "uint64":>
		if (o.<:.Name:>) {
			if (o.<:.Name:> > 18446744073709551616)
				throw 'colfer: field "<:.Name:>" overflow: ' + o.<:.Name:>;
			var seg = [<:.Index:>];
			encodeVarint(seg, o.<:.Name:>);
			segs.push(seg);
		}
<:else if eq .Type "int32":>
		if (o.<:.Name:>) {
			if (o.<:.Name:> > 2147483647 || o.<:.Name:> < -2147483648)
				throw 'colfer: field "<:.Name:>" overflow: ' + o.<:.Name:>;
			var seg = [<:.Index:>];
			if (o.<:.Name:> < 0) {
				seg[0] |= 128;
				encodeVarint(seg, -o.<:.Name:>);
			} else	encodeVarint(seg, o.<:.Name:>);
			segs.push(seg);
		}
<:else if eq .Type "int64":>
		if (o.<:.Name:>) {
			if (o.<:.Name:> > 9223372036854775807 || o.<:.Name:> < -9223372036854775808)
				throw 'colfer: field "<:.Name:>" overflow: ' + o.<:.Name:>;
			var seg = [4];
			if (o.<:.Name:> < 0) {
				seg[0] |= 128;
				encodeVarint(seg, -o.<:.Name:>);
			} else	encodeVarint(seg, o.<:.Name:>);
			segs.push(seg);
		}
<:else if eq .Type "float32":>
		if (o.<:.Name:> || Number.isNaN(o.<:.Name:>)) {
			if (o.<:.Name:> > 3.4028234663852886E38 || o.<:.Name:> < -3.4028234663852886E38)
				throw 'colfer: field "<:.Name:>" overflow: ' + o.<:.Name:>;
			var bytes = new Uint8Array(5);
			bytes[0] = <:.Index:>;
			new DataView(bytes.buffer).setFloat32(1, o.<:.Name:>);
			segs.push(bytes);
		}
<:else if eq .Type "float64":>
		if (o.<:.Name:> || Number.isNaN(o.<:.Name:>)) {
			var bytes = new Uint8Array(9);
			bytes[0] = <:.Index:>;
			new DataView(bytes.buffer).setFloat64(1, o.<:.Name:>);
			segs.push(bytes);
		}
<:else if eq .Type "timestamp":>
		if (o.<:.Name:>) {
			var ms = o.<:.Name:>.getTime()
			var s = ms / 1000;
			var ns = (ms % 1000) * 1E6;
			if (o.<:.Name:>_ns) ns += o.<:.Name:>_ns % 1E6;

			var bytes = new Uint8Array((ns) ? 13 : 9);
			bytes[0] = <:.Index:>;
			var view = new DataView(bytes.buffer);
			view.setUint32(1, s / Math.pow(2, 32));
			view.setUint32(5, s % Math.pow(2, 32));
			if (ns) {
				bytes[0] |= 128;
				view.setUint32(9, ns);
			}
			segs.push(bytes);
		}
<:else if eq .Type "text":>
		if (o.<:.Name:>) {
			var utf = encodeUTF8(o.<:.Name:>);
			var seg = [<:.Index:>];
			encodeVarint(seg, utf.length);
			segs.push(seg);
			segs.push(utf)
		}
<:else if eq .Type "binary":>
		if (o.<:.Name:>) {
			var seg = [<:.Index:>];
			encodeVarint(seg, o.<:.Name:>.length);
			segs.push(seg);
			segs.push(o.<:.Name:>);
		}
<:end:><:end:>
		return joinSegs(segs);
	}
`

const ecmaUnmarshal = `	this.unmarshal<:.NameTitle:> = function(data) {
		if (!data || ! data.length) return null;
		var i = 0;
		if (data[i++] != 0x80) throw StructMis;

		var readVarint = function() {
			var pos = 0, result = 0;
			while (true) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					return result;
				}
				if (pos == data.length) throw EOF;
			}
		}

		var o = {};
		if (i == data.length) return o;

		var header = data[i++];
		var field = header & 127;
<:range .Fields:>
		if (field == <:.Index:>) {<:if eq .Type "bool":>
			o.<:.Name:> = true;
<:else if eq .Type "uint32":>
			o.<:.Name:> = readVarint();
<:else if eq .Type "uint64":>
			o.<:.Name:> = readVarint();
<:else if eq .Type "int32":>
			o.<:.Name:> = readVarint();
			if (header & 0x80) o.<:.Name:> *= -1;
<:else if eq .Type "int64":>
			o.<:.Name:> = readVarint();
			if (header & 0x80) o.<:.Name:> *= -1;
<:else if eq .Type "float32":>
			if (data.length < i + 4) throw EOF;
			o.<:.Name:> = new DataView(data.buffer).getFloat32(i);
			i += 4;
<:else if eq .Type "float64":>
			if (data.length < i + 8) throw EOF;
			o.<:.Name:> = new DataView(data.buffer).getFloat64(i);
			i += 8;
<:else if eq .Type "timestamp":>
			if (data.length < i + 8) throw EOF;
			var view = new DataView(data.buffer);
			// BUG(pascaldekloe): negative time offset not supported
			var ms = view.getUint32(i) * Math.pow(2, 32);
			ms += view.getUint32(i + 4);
			ms *= 1000;
			i += 8;
			if (header&0x80) {
				if (data.length < i + 4) throw EOF;
				var ns = view.getUint32(i);
				i += 4;
				ms += ns / 1E6;
				o.<:.Name:>_ns = ns % 1E6;
			}
			o.<:.Name:> = new Date();
			o.<:.Name:>.setTime(ms);
<:else if eq .Type "text":>
			var to = readVarint() + i;
			if (to > data.length) throw EOF;
			o.<:.Name:> = decodeUTF8(data.subarray(i, to));
			i = to;
<:else if eq .Type "binary":>
			var to = readVarint() + i;
			if (to > data.length) throw EOF;
			o.<:.Name:> = data.subarray(i, to);
			i = to;
<:end:>
			if (i == data.length) return o;
			header = data[i++];
			field = header & 127;
		}
<:end:>
		return UnknownField;
	}`
